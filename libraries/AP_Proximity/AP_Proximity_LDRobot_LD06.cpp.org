/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_LDRobot_LD06.h"

#if 0 // HAL_PROXIMITY_ENABLED
#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_Math/crc.h>
#include <GCS_MAVLink/GCS.h>

extern const AP_HAL::HAL& hal;


/**
 Data Format:

|Start Character|Data Length|Radar Speed|Start Angle|Data|End Angle|Timestamp|CRC check|
|54H 1 Byte     |LSB MSB    |LSB MSB    |LSB MSB    |... |LSB MSB  |LSB MSB  |1 Byte   |
 54 // 1
 2C // 1 44
 0E 0E // 2 3598 deg
 5B 50 // 2 206.35 deg
          //   距離    
 A9 00 26 // 1 16.9cm 38
 AB 00 2D // 2 17.1cm
 90 00 16 // 3 14.4cm
 AD 00 2A // 4 
 91 00 10 // 5
 83 00 33 // 6
 AE 00 19 // 7
 A3 00 23 // 8
 CD 00 64 // 9
 E2 00 D4 // 10
 D7 00 67 // 11
 14 01 4D // 12
 C2 53 // 2 214.42 deg 8.07
 98 5D   // 2 23960 ms
 7C  // 1
 54 
 2C 
 0E 0E 
 0D 54 215.17
 AF 00 47 A4 00 50 A9 00 6D B3 00 AE BF 00 91 C5 00 91 BA 00 71 B4 00 60 C7 00 4D BB 00 64 BC 00 47 B5 00 4A 
 69 57 223.77
 9B 5D 23963 ms
 F8 


starting character：Length 1 Byte, fixed value 0x54, meansthe beginning of data packet;
Data Length: Length 1 Byte, the first threedigits reserved, the last five digits represent the number of measured points in a packet, currently fixed value 12;
Radar speed：Length 2 Byte, in degrees per second;
Start angle: Length: 2 Byte; unit: 0.01 degree;
Data: A measurementdata length is 3 bytes, please refer to next section for detailed explanation;
End Angle: Length: 2 Byte; unit: 0.01 degree；
Timestamp: Length2 Bytes in ms, recount if reaching to MAX 30000；
CRC check：Checksum of all previous data；

|Baud Rate|Data Bits|Stop Bits|Parity Bit|Flow Control|
|230400   |8 Bits   |1        |No        |No          |
*/

#define PROXIMITY_LDROBOT_HEADER 0x54


#define ANGLE_PER_FRAME 12
#define HEADER 0x54

typedef struct PACKED {
    uint16_t distance;    // 
    uint8_t  confidence;  // 

} LidarPointStructDef;

typedef struct PACKED {
    uint8_t  startCharacter;  // 
    uint8_t  dataLength;      // 
    uint16_t radarSpeed;      // 
    uint16_t startAngle;      //
    LidarPointStructDef data[ANGLE_PER_FRAME];
    uint16_t endAngle;        // 
    uint16_t timestamp;       // 
    uint8_t  crcCheck;        // 
} LiDARFrameTypeDef;


static const uint8_t CrcTable[256] = {
    0x00, 0x4d, 0x9a, 0xd7, 0x79, 0x34, 0xe3, 0xae, 0xf2, 0xbf, 0x68, 0x25, 0x8b, 0xc6, 0x11, 0x5c,
    0xa9, 0xe4, 0x33, 0x7e, 0xd0, 0x9d, 0x4a, 0x07, 0x5b, 0x16, 0xc1, 0x8c, 0x22, 0x6f, 0xb8, 0xf5, 
    0x1f, 0x52, 0x85, 0xc8, 0x66, 0x2b, 0xfc, 0xb1, 0xed, 0xa0, 0x77, 0x3a, 0x94, 0xd9, 0x0e, 0x43, 
    0xb6, 0xfb, 0x2c, 0x61, 0xcf, 0x82, 0x55, 0x18, 0x44, 0x09, 0xde, 0x93, 0x3d, 0x70, 0xa7, 0xea, 
    0x3e, 0x73, 0xa4, 0xe9, 0x47, 0x0a, 0xdd, 0x90, 0xcc, 0x81, 0x56, 0x1b, 0xb5, 0xf8, 0x2f, 0x62, 
    0x97, 0xda, 0x0d, 0x40, 0xee, 0xa3, 0x74, 0x39, 0x65, 0x28, 0xff, 0xb2, 0x1c, 0x51, 0x86, 0xcb, 
    0x21, 0x6c, 0xbb, 0xf6, 0x58, 0x15, 0xc2, 0x8f, 0xd3, 0x9e, 0x49, 0x04, 0xaa, 0xe7, 0x30, 0x7d, 
    0x88, 0xc5, 0x12, 0x5f, 0xf1, 0xbc, 0x6b, 0x26, 0x7a, 0x37, 0xe0, 0xad, 0x03, 0x4e, 0x99, 0xd4, 
    0x7c, 0x31, 0xe6, 0xab, 0x05, 0x48, 0x9f, 0xd2, 0x8e, 0xc3, 0x14, 0x59, 0xf7, 0xba, 0x6d, 0x20, 
    0xd5, 0x98, 0x4f, 0x02, 0xac, 0xe1, 0x36, 0x7b, 0x27, 0x6a, 0xbd, 0xf0, 0x5e, 0x13, 0xc4, 0x89, 
    0x63, 0x2e, 0xf9, 0xb4, 0x1a, 0x57, 0x80, 0xcd, 0x91, 0xdc, 0x0b, 0x46, 0xe8, 0xa5, 0x72, 0x3f, 
    0xca, 0x87, 0x50, 0x1d, 0xb3, 0xfe, 0x29, 0x64, 0x38, 0x75, 0xa2, 0xef, 0x41, 0x0c, 0xdb, 0x96, 
    0x42, 0x0f, 0xd8, 0x95, 0x3b, 0x76, 0xa1, 0xec, 0xb0, 0xfd, 0x2a, 0x67, 0xc9, 0x84, 0x53, 0x1e, 
    0xeb, 0xa6, 0x71, 0x3c, 0x92, 0xdf, 0x08, 0x45, 0x19, 0x54, 0x83, 0xce, 0x60, 0x2d, 0xfa, 0xb7, 
    0x5d, 0x10, 0xc7, 0x8a, 0x24, 0x69, 0xbe, 0xf3, 0xaf, 0xe2, 0x35, 0x78, 0xd6, 0x9b, 0x4c, 0x01, 
    0xf4, 0xb9, 0x6e, 0x23, 0x8d, 0xc0, 0x17, 0x5a, 0x06, 0x4b, 0x9c, 0xd1, 0x7f, 0x32, 0xe5, 0xa8
};

uint8_t AP_Proximity_LDRobot_LD06::CalCRC8(uint8_t *p, uint8_t len)
{
    uint8_t crc = 0;
    uint16_t i;
    for (i = 0; i < len; i++) {
        crc = CrcTable[(crc ^ *p++) & 0xff];
    }
    return crc;
}



//step = (end_angle – start_angle)/(len – 1);
//angle = start_angle + step * i;





// void AP_Proximity_LDRobot_LD06::update(void)
// {}

float AP_Proximity_LDRobot_LD06::distance_max() const
{
    return 12.0f;
}

float AP_Proximity_LDRobot_LD06::distance_min() const
{
    return 0.02f;
}

bool AP_Proximity_LDRobot_LD06::initialise()
{
    return true;
}

void AP_Proximity_LDRobot_LD06::set_motor_speed(bool on_off)
{}

void AP_Proximity_LDRobot_LD06::set_motor_direction()
{}

void AP_Proximity_LDRobot_LD06::set_forward_direction()
{}

void AP_Proximity_LDRobot_LD06::request_new_data()
{}

void AP_Proximity_LDRobot_LD06::send_request_for_health()
{}

bool AP_Proximity_LDRobot_LD06::send_request_for_distance()
{}

bool AP_Proximity_LDRobot_LD06::check_for_reply()
{}

bool AP_Proximity_LDRobot_LD06::process_reply()
{}

void AP_Proximity_LDRobot_LD06::update_sector_data(int16_t angle_deg, uint16_t distance_cm)
{
    database_push(angle_deg, distance_cm);
}

#endif // HAL_PROXIMITY_ENABLED
